# 작업 공유하기

## 고루틴

### 동시성vs병렬성

- 동시성(Concurrency)

  - 논리적인 용어
  - **동시에 실행되는 것처럼** 보이는 것
  - 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식
    - 멀티코어에서도 사용은 가능함
    - 멀티 태스킹을 위해 여러개의 스레드가 번갈아가며 실행(하지만 컴퓨터 연산 속도가 워낙 빠르기 때문에 거의 동시처럼 보임)

- 병렬성(Parallelism)

  - 물리적인 용어

  - **실제로 작업이 동시에 처리** 되는 것

  - 멀티코어에서 멀티 스레드를 동작시키는 방식

    - 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 방식

    

### 프로세스? 쓰레드?

여러 작업을 동시에 처리할 때 사용되는 개념이 멀티 프로세스, 멀티 쓰레드 (운영체제 적인 관점)

- 프로세스(Process)
  - 운영체제에서 사용하는 task의 단위
  - 쉽게 말해 main 함수
  - 프로그램을 실행시키면 가장 먼저 켜짐
  - OS에 요청하여 프로세스를 실행시킬 수 있음
  - 프로세스는 또 다른 프로세스를 킬 수 있음
  - 메모리 영역은 독립적이고 서로 침범할 수 없음
  - 생성과 삭제, 동시성 처리에 필요한 컨텍스트 스위치(번갈아가며 실행)에 비용이 큼
- 쓰레드(Thread)
  - 모든 프로세스는 적어도 한 개의 쓰레드를 가짐
  - 프로세스를 다시 쪼갠 단위
  - OS에게 요청해서 생성
  - 같은 프로세스 내에 있는 쓰레드들은 특정 독립적인 부분을 제외하곤 메모리 영역 공유
  - 생성과 삭제, 컨텍스트 스위칭 시의 비용이 프로세스보다는 작음

### 고루틴(groutine)?

- OS에게 요청하지 않고 Go언어 내부에서 자체적으로 스케줄링하겠다! 하고 만든 것이 goroutine

  - 즉, 쓰레드나 프로세스를 OS에게 사용하게 해줘~!가 아닌 그냥 알아서 자체적으로 경량 쓰레드를 실행시켜서 사용
  - 경량 쓰레드라고 흔히 표현하나 엄밀히 말하면 OS가 관여하는 것이 아니라서 쓰레드라 부르기 애매
  - 내부에서 시분할처리 하여 동작하기때문에 동시성은 만족하지만 병렬성에 대해서는 애매
  - OS 요청이 없기 때문에 비용이 프로세스보다 월등히 적음
  - Main 함수 역시 고루틴을 통해 실행 됨

- 고루틴의 실행 시점은 제어 불가능 

- 반환값(return)을 사용할 수 없음

  

## 채널

- 고루틴 간에 값을 전송하는 데 사용하는 데이터 구조

- 채널 생성 방법

  `myChannel := make(chan String)`

- 송수신

  ```
  myChannel <- value // send statement
  key := <- myChannel // receive expression
  close(myChannel)   // close Channel
  ```

  

- 맵과 마찬가지로 make로 생성 된 데이터 구조에 대한 참조



### 블로킹? 논블로킹? 동기화? 비동기화?

- 블로킹?
  - 작업이 진행되다가 다른 작업 주체가 하는 작업의 시작부터 끝까지 기다렸다가 다시 자신의 작업을 시작하는 것이 블로킹
  - 호출 된 함수가 자신의 작업을 모두 마칠 떄까지 호출 한 함수에게 제어권을 넘겨주지 않고 대기하도록 하는 것
- 논블로킹?
  - 호출된 함수가 바로 리턴해서 호출 한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 논블로킹
  - 다른 작업과 관계 없이 자신의 작업을 계속한다면 논블로킹
- 동기화?
  - 작업을 수행하는 두 개 이상의 주체가 서로 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작
- 비동기?
  - 두 주체가 서로의 시작, 종료시간과 관계 없이 별도의 수행 시작/종료 시간을 가질 때



**채널은 고루틴의 모든 작업을 중지하는 <u>블로킹</u>으로 고루틴의 송수신을 보장**

**이를 통해 고루틴은 자기 자신의 행동을 <u>동기화</u>**



